<link href="../polymer/polymer.html" rel="import">
<link href="../core-menu/core-menu.html" rel="import">
<link href="../paper-input/paper-input.html" rel="import">
<link href="../paper-shadow/paper-shadow.html" rel="import">
<link href="../core-icon-button/core-icon-button.html" rel="import">
<link href="../cg-input-select/cg-input-select.html" rel="import">
<link href="cg-dropdown.html" rel="import">
<link rel="import" href="../font-awesome-polymer-icons/fa-icons.html">

<polymer-element name="cg-input-tags" extends="cg-lightdom-element" attributes="label tags selected required">
    <template>
        <style>
            cg-input-tags .placeholder {
                color:#9a9a9a;
            }
            /*cg-input-tags .tag-input {*/
                /*padding:6px;*/
            /*}*/
            /*cg-input-tags .tag-input:hover {*/
                /*border:1px solid #dddddd;*/
                /*padding:5px;*/
            /*}*/
            cg-input-tags .tags paper-shadow {
                margin:3px;
                padding:3px;
            }
            cg-input-tags .tags paper-shadow /deep/ core-icon {
                width:16x!important;
                height:16px!important;
                color:#ee0000!important;
            }
            cg-input-tags /deep/ core-icon {
                color:rgb(0, 150, 136)!important;
            }
            cg-input-tags cg-dropdown /deep/ paper-item:hover {
                background-color:#dddddd;
            }
        </style>
        <input is="core-input" required?="{{required}}" value="{{selected}}" id="input" hidden>
        <div layout horizontal on-tap="{{_select}}" class="tag-input">
            <div flex class="tags" layout horizontal wrap center>
                <template if="{{selected.length > 0}}">
                    <template repeat="{{selected as tag}}">
                        <paper-shadow z="1">{{tag}}&nbsp;<core-icon icon="fa:minus-circle" on-tap="{{_delete}}" data-value="{{tag}}"></core-icon></paper-shadow>
                    </template>
                </template>
                <template if="{{selected.length == 0}}">
                    <span class="placeholder">{{label}}</span>
                </template>
            </div>
            <div>
                <core-icon icon="fa:caret-down" ></core-icon>
            </div>
        </div>
        <div relative>
            <cg-dropdown id="dd" class="dropdown" on-core-select="{{_onAdd}}" layered>
                <paper-input id="search" label="Search or new" role="header" on-keyup="{{_search}}" on-keypress="{{_selectOrNew}}"></paper-input>
                <core-menu class="menu" id="menu">
                    <template repeat="{{_tagsView as tag}}">
                        <paper-item data-value="{{tag}}">{{tag}}</paper-item>
                    </template>
                </core-menu>
            </cg-dropdown>
        </div>
    </template>
    <script>
        Polymer("cg-input-tags", {
            label:null,
            required:false,
            tags:[],
            selected:[],
            _tags:[],
            _tagsView:[],
            _decoratorElement:null,
            domReady:function(){
                if(this.parentElement.tagName.toLowerCase() == "paper-input-decorator") {
                    this._decoratorElement = this.parentElement; // _decoratorElement thing's quite nasty..
                    this.label = this._decoratorElement.getAttribute("label");
                }
            },
            tagsChanged:function(){
                this._tags = this.tags.slice();
            },
            selectedChanged:function(){
                for(var i = 0; i < this.selected.length; i++){
                    var tag = this.selected[i];
                    this._tags.splice(this._tags.indexOf(tag), 1);
                }
                this.$.input.value = this.selected.toString();
                this._decoratorElement && this._decoratorElement.inputChanged();
                this.fire("change", this.selected);
            },
            _tagsChanged:function(){
                this._tagsView = this._tags.slice();
            },
            _select:function(e){
                this.$.dd.toggle();
            },
            _delete:function(e){
                for(var i = 0; i < this.selected.length; i++) {
                    if(this.selected[i] == e.currentTarget.dataset.value) {
                        var o = this.selected.splice(i, 1)[0];
                        if (this.tags.indexOf(o) != -1) {
                            this._tags.splice(0, 0, o);
                        }
                        break;
                    }
                }
                e.stopPropagation();
            },
            _onAdd:function(e) {
                this._add(e.detail.item.dataset.value);
            },
            _add:function(tag){
                for(var i = 0; i < this.selected.length; i++) {
                    if(this.selected[i] == tag) {
                        return;
                    }
                }
                this.selected.push(tag);
                this._decoratorElement && this._decoratorElement.inputChanged();
                this.$.menu.selected = null;
            },


            _selectOrNew:function(e){
                if(e.keyCode != 13) {
                    return;
                }
                if(this._tagsView.length == 1) {
                    this._add(this._tagsView[0]);
                }else{
                    var tag = this.$.search.value;
                    for(var i = 0; i < this.selected.length; i++) {
                        if(this.selected[i] == tag) {
                            return;
                        }
                    }
                    this.selected.push(tag);
                }
            },
            _search:function(e){
                var highRelevance = [];
                var lowRelevance = [];
                this._tags.forEach(function(e){
                    var bounds = this._getMatchBounds(e);
                    if(bounds.matches) {
                        if (bounds.from == 0) {
                            highRelevance.push(e);
                        } else {
                            lowRelevance.push(e);
                        }
                    }
                }.bind(this));
                var results = highRelevance.concat(lowRelevance);
                this._tagsView = results;
            },
            _getMatchBounds:function(tag){
                var search = String(this.$.search.value).toLowerCase();
                if(search.length == 0) {
                    return {
                        empty : true,
                        matches : true,
                        from : -1,
                        to : -1
                    };
                }
                var value = tag.toLowerCase();
                var from =  value.indexOf(search);
                var matches =  from > -1;
                var to = matches ? from + search.length : -1;
                return {
                    empty:false,
                    matches: from > -1,
                    from: from,
                    to: to
                };
            }
        });
    </script>
</polymer-element>